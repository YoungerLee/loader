// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.4.5
// - protoc                        v3.19.3
// source: item_conf.proto

#include "item_conf.pc.h"

namespace tableau {
const std::string ItemConf::kProtoName = "ItemConf";

bool ItemConf::Load(const std::string& dir, Format fmt, const LoadOptions* options /* = nullptr */) {
  bool ok = LoadMessage(dir, data_, fmt, options);
  return ok ? ProcessAfterLoad() : false;
}

bool ItemConf::ProcessAfterLoad() {
  // OrderedMap init.
  for (auto&& item1 : data_.item_map()) {
    ordered_map_[item1.first] = &item1.second;
  }

  // Index init.
  for (auto&& item1 : data_.item_map()) {
    index_item_map_[static_cast<int>(item1.second.type())].push_back(&item1.second);
  }

  for (auto&& item1 : data_.item_map()) {
    for (auto&& item2 : item1.second.param_list()) {
      index_item_info_map_[item2].push_back(&item1.second);
    }
  }

  for (auto&& item1 : data_.item_map()) {
    for (auto&& item2 : item1.second.ext_type_list()) {
      index_item_ext_info_map_[static_cast<int>(item2)].push_back(&item1.second);
    }
  }

  return true;
}

const protoconf::ItemConf::Item* ItemConf::Get(uint32_t key1) const {
  auto iter = data_.item_map().find(key1);
  if (iter == data_.item_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const ItemConf::Item_OrderedMap* ItemConf::GetOrderedMap() const {
  return &ordered_map_; 
}

const ItemConf::Index_ItemInfoMap& ItemConf::FindItemInfo() const { return index_item_info_map_ ;}

const ItemConf::Index_ItemInfoVector* ItemConf::FindItemInfo(int32_t param_list) const {
  auto iter = index_item_info_map_.find(param_list);
  if (iter == index_item_info_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemInfo(int32_t param_list) const {
  auto conf = FindItemInfo(param_list);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

const ItemConf::Index_ItemExtInfoMap& ItemConf::FindItemExtInfo() const { return index_item_ext_info_map_ ;}

const ItemConf::Index_ItemExtInfoVector* ItemConf::FindItemExtInfo(protoconf::FruitType ext_type_list) const {
  auto iter = index_item_ext_info_map_.find(static_cast<int>(ext_type_list));
  if (iter == index_item_ext_info_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemExtInfo(protoconf::FruitType ext_type_list) const {
  auto conf = FindItemExtInfo(ext_type_list);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

const ItemConf::Index_ItemMap& ItemConf::FindItem() const { return index_item_map_ ;}

const ItemConf::Index_ItemVector* ItemConf::FindItem(protoconf::FruitType type) const {
  auto iter = index_item_map_.find(static_cast<int>(type));
  if (iter == index_item_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItem(protoconf::FruitType type) const {
  auto conf = FindItem(type);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}


}  // namespace tableau
